//Quick Scripts v2 by Jack Wilson, Navlight Games 2021.
//Thank you for purchasing this product.

using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace QuickScripts
{
    public class QS_TrackSection : MonoBehaviour
    {
        [HideInInspector]
        public QuickTrack parentTrack;
        [HideInInspector]
        public int orderNumber; // What number are we in the line? 0 = first. Not sure this is used.
        [HideInInspector]
        public QS_TrackNode startNode;
        [HideInInspector]
        public QS_TrackNode curveHandle;
        [HideInInspector]
        public QS_TrackNode endNode;
        private Transform curvePointContainer;

        [Space(10)]
        public bool overrideMoverSpeed;
        public float newSpeed;
        [Range(0, 1)]
        public float speedChangeSeverity = 1; // 1 = Instant speed change on this section. Lesser means eased over length of section

        [HideInInspector]
        public bool selectedInEditor;
        
        [HideInInspector]
        public List<Transform> trackSectionTransforms = new List<Transform>(); // for nodes generated by the curve
        private Vector3[] measurements = new Vector3[10];

        [HideInInspector]
        public Color gizmoColor;

        [HideInInspector]
        public float GetSectionLength()
        {
            float length = 0;
            int index = 0;

            measurements[9] = endNode.transform.position; // Do this here...

            for (float f = 0; f < 1; f += 0.1f)
            {
                if (index < 9)
                {
                    measurements[index] = Mathf.Pow(1 * f, 2) * endNode.transform.position +
                       curveHandle.transform.position * 2 * f * (1 - f) +
                       Mathf.Pow((1 - f), 2) * startNode.transform.position;

                    index++;
                }
            }

            for (int i = 0; i < measurements.Length -1; i++)
            {
                length += Vector3.Distance(measurements[i], measurements[i + 1]); //... so this works here
            }

            storedSectionLength = length;
            return length;
        }
        [HideInInspector]
        public float storedSectionLength; // Fix this structure in future. Could be cleaner.
        [HideInInspector]
        public float sectionPercentOfWhole;
        private float previousFrameSectionLength;

#if UNITY_EDITOR
        private void OnDrawGizmos()
        {
            if (curveHandle == null)
            {
                MakeCurveHandle(false);
            }

            GetSectionLength();
            if (previousFrameSectionLength != 0 && previousFrameSectionLength != storedSectionLength)
                UpdateNodeCount();

            previousFrameSectionLength = storedSectionLength;

            if (selectedInEditor)
            {
                Gizmos.DrawWireCube(startNode.transform.position, Vector3.one * 2);
                Gizmos.DrawWireCube(endNode.transform.position, Vector3.one * 2);
            }
            

            // Destroy End Node if accidentally duplicated
            if (transform.childCount == 5 && transform.GetChild(4).name == "End Node (1)")
            {
               
                GameObject toGo = transform.GetChild(4).gameObject;
                GameObject.DestroyImmediate(toGo);

                if (parentTrack.trackSections.Count > 1 && parentTrack.trackSections.IndexOf(this) < parentTrack.trackSections.Count - 1)
                    parentTrack.InsertTrack(this);
                else
                    parentTrack.AddTrackSection();

            }

            if (transform.childCount < 4)
            {
                UnityEditor.EditorUtility.DisplayDialog("Quick Scripts Warning",
                    "Oops, did you delete something from your Quick Track?"
                    + " An automatic fix has been attempted, but results may vary. Next time please use the"+
                    " Inspector button 'Delete This Track Section' to delete your objects instead.", "OK");
                parentTrack.DeleteThisTrack(this);   
            }

            
            if (!parentTrack.drawGizmos)
                return;


           

           

            if (overrideMoverSpeed)
                gizmoColor = Color.red;
            else
                gizmoColor = parentTrack.gizmoColor;

            if (parentTrack.trackType == QuickTrack.moverTrackTypes.complex)
            {
               
                float step = 1.0f / trackSectionTransforms.Count;
                float t = 0;
                
                for (int i = 0; i < trackSectionTransforms.Count; i++)
                {

                    // Set Curve Point Position
                    Vector3 newPos = Mathf.Pow(1 * t, 2) * endNode.transform.position +
                    curveHandle.transform.position * 2 * t * (1 - t) +
                    Mathf.Pow((1 - t), 2) * startNode.transform.position;

                    trackSectionTransforms[i].position = newPos;

                    // Set Curve Point Rotation
                    Quaternion newRot = Quaternion.Slerp(startNode.transform.rotation, endNode.transform.rotation, t);
                    trackSectionTransforms[i].rotation = newRot;

                    t += step;
                }

                // Now Draw Gizmos

                for (int ii = 0; ii < trackSectionTransforms.Count; ii++)
                {
                    Transform currentPoint = trackSectionTransforms[ii];
                    Transform targetPoint;
                    Gizmos.DrawIcon(currentPoint.position, "d_PreMatSphere");


                    // If not the last gizmo
                    if (ii + 1 < trackSectionTransforms.Count)
                    {
                        targetPoint = trackSectionTransforms[ii + 1];
                    }
                    else
                    {
                        targetPoint = endNode.transform;
                    }

                    Vector3 bumpLeft = (currentPoint.right / 2) * -1;
                    Vector3 bumpRight = currentPoint.right / 2;


                    // Speed Gizmos
                    // Brake Intensity
                    if (overrideMoverSpeed)
                    {
                        Gizmos.color = Color.red;

                        // Left Line
                        Gizmos.DrawLine(currentPoint.position + bumpLeft / 2,
                            targetPoint.position + bumpLeft / 2);

                        // Right Line
                        Gizmos.DrawLine(currentPoint.position + bumpRight / 2,
                           targetPoint.position + bumpRight / 2);
                    }


                    Gizmos.color = gizmoColor;


                    // Left line
                    Gizmos.DrawLine(currentPoint.position + bumpLeft,
                        targetPoint.position + bumpLeft);

                    // Right Line
                    Gizmos.DrawLine(currentPoint.position + bumpRight,
                       targetPoint.position + bumpRight);

                    // Cross Line
                    Gizmos.DrawLine(currentPoint.position - currentPoint.right,
                        currentPoint.position + currentPoint.right);

                    // Vertical Line
                    Gizmos.color = Color.green;
                    Gizmos.DrawLine(currentPoint.position, currentPoint.position + currentPoint.up / 2);

                    // Pointer Line
                    Gizmos.color = Color.blue;
                    Gizmos.DrawLine(currentPoint.position, currentPoint.position + currentPoint.forward / 2);

                }

                // Draws the Fancy Gizmo Curve
                //for (float t = 0; t <= 1; t += 1 / trackSectionTransforms.Count) // Change to make step = number of nodes
                //{

                // gizmosPosition = Mathf.Pow(1 * t, 2) * endNode.transform.position +
                //  curveHandle.transform.position * 2 * t * (1 - t) +
                //  Mathf.Pow((1 - t), 2) * startNode.transform.position;

                //    Gizmos.DrawIcon(gizmosPosition, "d_PreMatSphere");

                //}

                


                curveHandle.gameObject.SetActive(true);

                Gizmos.color = Color.white;
                Gizmos.DrawLine(curveHandle.transform.position, endNode.transform.position);
                Gizmos.DrawLine(curveHandle.transform.position, startNode.transform.position);

            }
            else // if Simple Track
            {
                Gizmos.color = gizmoColor;

                Gizmos.DrawLine(startNode.transform.position, endNode.transform.position);
                curveHandle.gameObject.SetActive(false);
               
            }

           

            //Lock start node to same pos as prev track's end node
            if (orderNumber > 0)
            {

                if (startNode.name != "Link Node") startNode.name = "Link Node"; // This one line solved the Rename bug. Lol ok? Dont change it.
                startNode.transform.position = parentTrack.trackSections[orderNumber - 1].endNode.transform.position;
                startNode.transform.rotation = parentTrack.trackSections[orderNumber - 1].endNode.transform.rotation;
                startNode.gameObject.SetActive(false);
            }

            

        }

        void UpdateNodeCount()
        {

            for (int i = 0; i < trackSectionTransforms.Count; i++)
            {
                DestroyImmediate(trackSectionTransforms[i].gameObject);
            }
            trackSectionTransforms.Clear();

            float nodes = (Mathf.Round(storedSectionLength)) / 2; // guarantees curve fidelity

            for (int i = 0; i < nodes; i ++)
            {
                GameObject curveTransform = new GameObject();
                curveTransform.name = "curveTransform " + i;
                if (curvePointContainer == null) curvePointContainer = this.transform.GetChild(3).transform;
                curveTransform.transform.SetParent(curvePointContainer);
                curveTransform.transform.localPosition = Vector3.zero;
                trackSectionTransforms.Add(curveTransform.transform);
            }

        }

        public void SetUpSelf(QuickTrack owningTrack, int trackSectionIndex, bool insert) // Called from QSEditor_QuickMover on Add Track Section
        {
            parentTrack = owningTrack;
            orderNumber = trackSectionIndex;

            //if first trackSection, trackSectionIndex will be 0
            if (trackSectionIndex > 0 && insert == false)
            {
                this.transform.position = parentTrack.trackSections[trackSectionIndex - 1].endNode.transform.position;
                this.transform.rotation = parentTrack.trackSections[trackSectionIndex - 1].endNode.transform.rotation;
            }


            GameObject _startNode = new GameObject("Start Node");
            _startNode.transform.SetParent(this.transform);
            _startNode.transform.localPosition = Vector3.zero;
            startNode =  _startNode.AddComponent<QS_TrackNode>();
            startNode.myTrackSection = this;


            GameObject _endNode = new GameObject("End Node");
            _endNode.transform.SetParent(this.transform);
            if (insert == false)
                _endNode.transform.localPosition = Vector3.forward * 5;
            else // If being inserted, align the new End Node to look at the next End Node
            {
                _endNode.transform.localPosition = Vector3.zero;
                _endNode.transform.LookAt(parentTrack.trackSections[trackSectionIndex].endNode.transform.position);
            }

            endNode = _endNode.AddComponent<QS_TrackNode>();
            endNode.myTrackSection = this;
            if (trackSectionIndex > 0 && insert == false)
                _endNode.transform.rotation = parentTrack.trackSections[trackSectionIndex - 1].endNode.transform.rotation;

            MakeCurveHandle(insert);

            GameObject curveTransformContainer = new GameObject();
            curveTransformContainer.name = "curvePoints";
            curveTransformContainer.transform.SetParent(this.transform);
            curveTransformContainer.transform.localPosition = Vector3.zero;

            curvePointContainer = curveTransformContainer.transform; // This could be better...

            GetSectionLength();
            UpdateNodeCount();

        }

        void MakeCurveHandle( bool insert)
        {
            GameObject _curveHandle = new GameObject("Curve Handle");
            _curveHandle.transform.SetParent(this.transform);
            if (insert == false)
                _curveHandle.transform.localPosition = Vector3.forward * 2.5f;
            else
            {
                _curveHandle.transform.localPosition = endNode.transform.localPosition - endNode.transform.forward * 2.5f;
                _curveHandle.transform.rotation = endNode.transform.rotation;
            }

            curveHandle = _curveHandle.AddComponent<QS_TrackNode>();
            curveHandle.myTrackSection = this;
            curveHandle.nodeType = QS_TrackNode.moverNodeType.handle;

            QuickGizmo tempGizmo;
            tempGizmo = _curveHandle.GetComponent<QuickGizmo>();
            tempGizmo.gizmoType = QuickGizmo.currentGizmoType.cube;
            tempGizmo.gizmoRadius = 0.25f;
            tempGizmo.gizmoColor = Color.white;
        }

#endif
    }
}